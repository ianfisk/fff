<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <link rel="icon" href="data:image/svg+xml;utf8,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20viewBox%3D%220%200%20100%20100%22%3E%3Ctext%20y%3D%22.9em%22%20font-size%3D%2290%22%3E%F0%9F%8E%83%3C%2Ftext%3E%3C%2Fsvg%3E">
        <title>FFFF</title>
        <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no"/>

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: url(img/texture.jpg);
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: url(img/flames.gif);
                background-position-y: center;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: url(img/stars.gif);
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Your password is the key to your internet wonderland</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"9ccb0df7e19b3e14cbe23765d15d1558a4fd1cf76866001700a5b4b713cbd6921c9bf6ffe0f36a46ca57d14d5d9efe1edbf4dd6cf146ad7b77238b9d1fe412a550a175d509af5fedabaf9aa1277463752b92eddb7fcbd102475a66db4dcebadbb2875637b80a48c4baee631bf2cd0c0df423cc40eae5b4ed620675c55356abab9f5b7e2baae617800c2a422929816fffd378e7383e071b08ef6ff75da0570d773328bb8087af3c9b3fdf610ea66f33154ba26f98cca07bec3014f458d1e388aa37a217cb71e5444f0bf60d10ae45647d5ecd5f2ea44ebf51632c2538a0fbe66c22285ec7724134c42604ea270e14d8c3122b01d309661924d157b433d128d8ac7408ea815db8581c250c64472d09538cbd65aeacfe098eb8c2392b436b68e2bf117054b0cd6e34ff33f610f51b8300148ce9e80f5cca75a6158c05ccfbd06d960f747753f8030d314d7f169bb957da6993ef585e70d283403f5910eb2904f8b1d9a73419bbb45bc8a852469323b7bf3ed579dfaa0ca63c1528d33cab2a3fd9fd13c945016f44683ec230852263f360e46cdcc9ad9b82424b6397e29a3214f0cdac201467cec990cc2f67e58658effb53c4839c018b55980de22a7584933d2658ce0b42615ce4baa69584e0b77694dc394406d34cada2f113873574760ed4de8abec9e8767363ff7619612092b61e1d2e3389e6e457a245f05a370de44f586254db5ddf2e8eb4845b7728a256ee74b325dda34f5c76196d83c374f6108b6fdb75fe56611892b1bfeed6088a4b804181f939029654b28e0ad7ff33afc08487b43b8209da590303424eaeed0ed1a97a85033eec4dd41b8a0b77682ac5804a4b9811f943837a39d86d97875c31fddbec4fb4d2ada9ecffe712822337f81db1e5ed5036568e9030304d51b7d6458a553dca2460e5c49909b7c4b4447d6c6025df91f46ee0e3d70b9bc7b831ec568d7b99524df0b6962fc14b86e40f325194c3dee5483b521d16074a9b81d72e6d6c50b72ebaa96cd8450be4e32cd8bf86ced40b8f79e6e6b996946d6c0e5e1e9bfcaf8317896733721a8cc4fd400d303dd0cb82942b43eabb5f5f682d1115e6882d85db8b47226df75103ebc4b1e00ade51357b3843ea8cf9a016939f82f3e0e38be2332385a69df88230308a1fb064309ecd8f4d351c4b3c891aab024dbc2a55e597d7d3bfa87204c05d9d45ef477e48f8f98fb36c277ba0e45994e53359ec0c60014796eaf41044791d50de15b2b795c889c5f357a5f6537bc45f648887f5e21500caddfeff39aae4f11aeaa66b52e2052e758bd3952f09bd0b4f9ce179521fb872e2670fce42bea237f4c01869168db3ea1c7c9090295592f6c587b05e7397eba2ce843df90e216459487a0a30edd955a4508e96240f3b81ed573f42c0d3a4e3c7b64df76dfea585d37efa9155ea141729a31e93da187dac3d2831c78cccfe5e1721283073a0897cfac437962390e314e55ce9a1645496f3897b00937e6cba3d9f71654adf851cf0c6d3909dfa8bb2655ab30ff1431c39b7178439b8a5c35f3aad5b19e64885beefd50f03275c11309b9a14157a7bbdce8626b49a7aa0cb351fa78b6121fda6ad65b586b9ecd0286b4ec377a948ea54a790bf35c8e201b3045282070984374ee86bdaee9875ce6b8f387b2d607e687fd3b7b2f60089c831b36c1e18ad3ca1ac3f1a5a1cde06541703780b98ba7d06f167a4ca46606946c6b870b8a047235b4c467c7fffb31c8b301d4644cc55022d6cad34779bff1067a9e4ba4b36bf8196572a34b6ac278d7f00bff2fce09b8a349adb9f6c55dc50f073fbdd1f7b4998336113e9ed80233f769a9e4e3995c0ec4a460f5cc995b5821a4978c864b005474127155f5af7097f75564efd751c7d408074e27142544d1f9db4940d82f0e8a7fe8bb8e4b54efd2a96d957016950844b68b349fa3c04a599a8662fe0076a23d369938f95d5f963c8baee587dfcfe58b18d57c27c984c081aa0df49ca884166ddeda1a48669cb510260be38553dacf044c010a360c2fd5b01be80cd65a3e4f6985a739b51bd4820cc0ea79b102df8563f63dc0f8e2db48d1a911794c12007478715dc4a32b08d0e554104abadd4ecf48be403bea86f49f19a038caa778494a7b86519dbdd907d3ae6f5e29f79fdff5be1e5ff1aa46f1333b560b0a1851b1b831cc10cd5db8af16b518a76316b7fc6bf3493f120d0be104d64465f2e526643f25db698446d669543ea286a2d56e30c2609d94d4a5a648688ff90040f34daf0a159577e4bf63dd47b126dd6fb4d9796d3fb24945bf7c92d045307e70cf63c8e10f6d831e35d0271b80ab75668be601f3e5ee1f53a4700d5251be2baddff142d9fbf2afd74172925ef628ce35d7a69f4fae17944db8ea11634d342b29bd118f1501b40e77d3178585d132de927acb4cca4f9d6ca85cfb8768740a165d321f4e0a09185aeca35a49227de152e8fe30ce11458bd18b4c4989da51914b9ccf38726e723b40334db803a5e44a5594833ecb7629a12ad0a1b7bf6ddf73907d4b46fc0e0ab9a7c3d125b97a933704c87cce66a9fe84824f21adcb0c86fd3073a0c5256a0ad62ba28e78407996585bffa3c67e78fb3e79f871e3a672392af6169b102034e13a3bd72e9aa0919f76031daed3809ad16458693ee0d806eaff399386f5604f16482c9bdf299c4b9c8e353ca86eba94738fe7b28d07a519b44acdd129657928547c4cc986b07c08fdd4474593950ae01752d4a27dd687ae0bbb05d6d4223417fa0c042b06e4b27d01167a02e3d2f270e343b1318cb693c3626f83c7bfda99b9482babcf0c24ca2d1ad8a13006f5fd455e5e74a50b9eb10fee0728f54de023f598ea0f6076434967f16cf196dbd3f1d4ded6a2848fc0a4d294878edd2d8c64abc7ae5fa0d431198a2e9ed5d1b0d05f9862c6bae8a9f59bef5f6c93f9db0d8d521baf0c612fe51d08a38c5a4552872b9fdd88bf4ba308d190e82390cf2a620643718047605c093dfa000b88814e30b39e37de2611eb411491b04b3f355a796f432e652ee18e60015ba932ed9a482f6d54862bbccc1481ec9f5beba0068ddbe88539a9944295b01b8a204344a5f945de2b54e10a0a9c94112ba3e83e5fa7ce9fc2f4d22ecef1d14e60bde14981c06221477ba7978ce1bf24488932a11a8d01e92dccc2114be130d355c228e5a4002fc250a8d07dbd322dc68575d1c4d0b67bf1a54addfe6e1508a7b79f3bd32c35e4863c08c5db4f0ade3729ff97a87fb71687e5fe0d17f97532ea1d40082fa193739ad50ef05633f6547526e87d6b1745da7bf803667e42eea5542d63c4bf5db3b527f80fd63654bccb58a53f5aef054eb3436745d27e9883ca06c8e10633e279e7fbdaa9992032e37802660591f25ec30c26238ea0459b5c37fc0d2b01341da9c8cb2c7474fe6464858948d3640768dc285ff994d047021679169e22f89744d4160de70b34adc00248d1e50c070cf5fd8f93c63dc2364dc985c90770c32a93b400c5137414661ea1d7dfcdfa3d35a1e8fcba9a6ce00b50e0e5beb779b3b3ee58359cd441e46fed3c1e0ee5447b11a2bc67912bd5befa4bd7943239ab8e2abd9698f20ef8ece57165fa0115e3d7e013f0ad9698f70968008bfe7c787382130ffa204800d0464c4f30ef8c967e03164be2f2d340416a29e79da9d3f2d26d17300f2e21d59df5310e446e170ac813a7157db583b508253ece16d3428d2fdf49239dae2aaa79799a87361fae64ccb7e382419801433419f7c1f2df2bed33e0f87b87299aaf6cdcf2fe0f43588f3a30f87b848973ccb09479f9c5d13a889a3c8ad8e9fba9fa170bc556cdc127bb7810432b983b928b865cd4ba926350a5e7ff425e12444a0816c5a683ad49a621869fcbd7c9ae9d409bc4d6155578f353df37b4811968209ae78aca1fdb0f5d3c0e45dc4855f0818ad5bdaf5f3407d2c1c4df46781431a52160ab0909e48aa00ea333cd8687ee96e8759483816de72cf76f8a4be8e2cbfb232b01c37fef000ddceee30066d632bd6fe4356f290911004a61885b20d4888bb3162f240c62bf5ca16d18f4fce9b873ea130f8c81e7f158917c3e1929234fd1227fd61cebcad68936e2e3e3888a7f92c588d2d5e231bfa765ae4228676b48366c36c2bf29611aa7810cc52e8aad4f8b35bf65fef6f49444e33fa5940cd5622f483022ee02b80aeedd60d729e1a602dd735176189524c868487910d2236b4c6f03d7efa6c0c539672deff31083cfed64542ff7d9bcb1613dda89d0f1a891c80d9f15757b17a0dd0fcbbcbd7c3c26c9fae31ddbcfccca8779ee2fac1302f51f7e1b4a127c95c13aa40b13dab9e4bb29579004c30fffc0aa2dfe69f47d995cbbfb06f89fd1c596c1cdb836c3c64ca74769be11bb8ef653c041dc04a503040fd5b66758e106583fdd0f3147a9ab7dcfb5cf93a4b8dcd2c121a45b167af7a69f543b023e4f05297c97d89c298ec52c7b0ff164fb6d81bdadd88655d3e409a4505001ec16c15accb177d6553ddacb0adbdb00e9ef0017bd6daf1063222e9b9a30abcc9a596e35bba6b42b41f4e85c57ede01c2daeee1efcde0d16854e88c4fbec2654d5767bafb08e459801372c12f77a3c071ce9ae0bd8cdc03cc24e9ac43674513d626a98225ab29b54de88b736d220296bafe384f45f2434e32a1488a1d95c231c3e652916905b4dddee40b63491d3518d7dcbafb5def33e41c7bf76273d69f3dcc701021cb36fcb9484ecb73fc80b40f2c488c169f630d547650321e443148fb912e7ea1f01a4fd958aace1dcbd374518ab07a8b8dbea4bdc8a03cce6ca5946a913003fa7e75cafb75becbb06f737b471c735fd685aa7e39976fdf0efaa88290134225c736fa96508e31d76c9e95b711beef19e2b5c3c3d7fa3bf61c7dd1d67f2a4926c350bf7366d248759cae093d9d7b64066d2095c737c8f2aec4c1fb224d2f0a9adf692872243a7948e24542b8bd84291544c597a37ac7434b66ba6bf72b39f71cd05dd2c65bc96564db8e427daab95a09663df96a5405430b9eab3a32b1d9a1e40bf52b84b1731c54b66b1311698cdebdbeeaa79f99b5193f5121966cd7a84a3be4e6b07dc78c19dcb00df0df74747c6acce0ec405b6bab7192b3d8cbcf641627a972dc67691eb21be2f53c36773d0bdf5acf22198c00b0c2dfe0b8312fcd7aa3a4ebe96e7f50e3fc1ba13265b88da275d118137a7cd825230ff1bc9647ad88182d6ade5bce407e15dd2b1699b2d1c68f73c33ea2f734f5c346fe4d4c071066aae1f2646f6a036a3d4805c8f49aae2f5c9752176574cec803f026d8a8c02afba34f60616997f8a129ac0f8a6a6277e8109d80e32ab82b5182df97b64f0ccd8f590c9f54090224a7258fac6a6d3a002fd23757db90f74d73b5ae4997ba177efab4a88a8c3672dcf9be2c68f74afba81024b6e466d1917ea6632217856718b00805809c7cc40dae4291130d797f7e8d8cf0dd38ebc5c35344f21d67ebd70111dfc592443ebc1b394db537cf0936691f25d2dfb136bf250dc116391c2be4b4fb7b3190bb2d0f81498d7d8cb1f0ccbb29f404af4d57116c2366898dc0f879d0a443740f92a7e4a3dde4f2e6d255760b424d95f909c929537d4e298282167d30fe9173b80470b718601ff333e3162b6a70e5b3ee592d0dd6bb0a75a51c0851d37287c497cbe8f671020c64b450121f9c886f5f4a35897e02596e3cb9b6afbf0264fdbc500755b18dbfeabfc7f42b4a27d3f70795b3360256f881826c21cb9bbbb6b9fb112fee5b5fff60223961ed7e370616747bfd0e34b1f09ebc4682b1b630473bb0b42e418b6db2688bead6a8ab03f19ac88a44f06b6f5ff47e4f62e147fc35024f8277abd9cdbf90f7894275e389f931a045e857d1eb3d53d1bc944ec420c777f226109ed5b91f04c393318995964b7e28e6618b1b83def19fe0745f857f5ddc62eb652641d5917009075cd543219e8852f4dd1b8976a81d13cb3eb99fd2bfafb174609de6fd31c242d156c5bdc4c8d79bc284fdeebcb0faeb3b49c897822f5115368a7acacb0b331dc1b2d052e43288fd0e4a591db23a6ff8817716996f72b3e296f9c0d8519b79641c4341bfd4f8a48432dcb0699c2eb8cc9dc535c781806861111afa7d049d7f2f867aeaa2bd7a1d56e347be3b420f0403c4da96d8bf820dec45a975cd51fb1283eb2c073e65cc4edcf6d7f1192297e092efbb63a5cc2534ce31c23f61088bc2a97da08bb7b25b680151d2914af64c63d721f11a1d149795e2fc089169d67bde66aa72e5b38d0ae3c56706f841ce4322f74d8de6f8f355a57ff53b0025af3cbd98cad6dc8cbbc2bac7610384b32e9ba92a3097d364845d04a109e69dfe229ba03c42f6c16049e74e27493adef0447d81862524546f8169255e24c96fca8395498a52f5b206748f01b0d7f37b9cd787c960429f3b64e7b417d07f966eda90b4157a3cfa3b2d035e2dde3a6497b541bd06aa5acf5e6a1f186969a646c541e0aa0b77ad8b46f218a0c5849ad09690e6fa602d3c73394003cb302f52aeda4feb13aa4fbb3969a6e06fd33457e9c258ced3855219ff2ebe4b81f90acccbda05e7e5f7dcca3a23da7271d184e19c0feaa2cb33740e3ca775b4d3053f5ff05c91ee383b41f7f9c72360d3e4aacafdc9f4a3be97da94c30f68ee07926195baa8f094e6ff8d41d8ae14dd671f0fe738f3e7f923542d1ea8e8ecb8cbef5733fabfe0483e114e96203ae4f0112e5abb5d378ce35b8047ff94b7c7ef3cc89c65a32ae156a709126923008d11ef46f0888d19514fb83987331b03f39c64c5851746e4f2cd6df72ad3cec1778ca74d10e2ddbe76a60f750ea94b03ee66c857560fb9219d0404859367715cbca5485785937685d18bcdd8e8769db64ef5b1c9ca7664affff690eb0e4745eacf51d2b401ee15d84b2f174c2dc31955a753cfa25a7bc890f2de98f7ce97ec71c3b2124817dbee79c2a9e57553ecb79b396fc024fed0ff80af41b78ca204ff8d759a979a3a3eab952aba347dc31bbdfb3774a5a8b86c56a17da53847f72b95d7d7fb62648ce65318c9ac1f0c6e08bc309c9b702a3b7b889f8be4e2c404839e2c4e54d67268cdd08d25394f2f6d0192d1f1f05d5d62becef71c4f1cd8199e87441d25b230969d28c3078657e36b2dae560635a53fdbf9de922e292ffa9a266da178bb7cebc7672ef365c8ac7ea50cdf1012c8e556943608c63714c2498184f3f67ccf90feeed44ff509c271514c503207c40778d248832f6c734029246401842c8dedd51df1f95d2b0bbf0dbe27506e8b5820cce65ccdcdf3fdb0b3036fca5cc5285c25f1b329917f6419f3d262acb5e8231d55556d6ce7cab600e113e4ef665ad85de86fac2be4f94e4316b5cd033d12527cc129ad1ee89d00d81861ce8f0b897efcfa3206a7d0738a1651e24a62ce3cc66ebeaf3630c73003575d5a28d6ac6671a058691fd0845c7608a6030117e6c809e7263780832b8edbe2e6a036891c6e273cfd542bf16779de2973d3ec583d5222a0280edc33b9219a5b3d255b298975893ae4bd683feb32b6568ec18a68f26a004fbc673c662d0d6c348f4ab1703c99d96a48accfaa1d9f456387a8731b3e36fe462a9305af18562199129d17d4cf23f5e93bd96a0ca46ef6dd25ac36ac0fec74e8200df4425e7dd47c0e25f779483d3505e78d7337bac8bfe6b810fdf2d73ce7c1d5426c2facc569e1117d2b794a3e75bdb5aaf57ebfc4cc8157aca0262a6e680ef348f5b741f0474280a6b2d7a0ce0bb48da68a68205ace6fe2d8a097db79a54bdc3e60dd7b4a9ed9fbdadc3808277f1618c83b6f44b25dcf7b3a9acb36d61e5e26730330161dbbff5320f0aa3382b3a6ce7f715ca28a9bf62818fb6eac3f37daad258debf4be1755b6fe7a4623e7011596e0042f8dda8c92bf9351ea495f38915ea111903680174604105ae4d27413542951485b5a91b4e4117f2a69ba8fc56fd24d6076b8da378418f33704688169a8ac095b4dfa3aaa67cee00faecd413690230f27adc760dd3e061bfdce6e7f59a530f856299f14cdfd37616b084842ee9697ada1dafcdeee593d0ff546859def5d045f041d28f6db3ebbb79de1d7cf64e2bb48222b3fc6c68f6a373063b82b09e698b8ff13a2d55cb281fbc05a23f7fa4d506e0b8aae6f4d659121d92ed82aa38646269388e226e399b2c2ced550dd1c0169908c76d21af3533c68c3cc6bff4266f2e55716953e05928f68456e33c91266fdb147dcc040231add56227d1bfbe45eeccc451c1d4cf60350efe3ebb8763d6110a5dd863dec319845834d9c0bd210e9942cdfb8bda1f387280a0049e83fd00877efdae1b71de61fb35681e9987e7d015ffbb039a0ea3825e94c412a3167838f064cdffdf37c0c5359e80f4e0274d39c2f6c4936530f1d83afbd2b5893084eb78965ec5b48ef2fff3b9043736f986afbaee2f09dc0b32cc6048754f2f5a5dc2827f65903313fb591b991a56035fe3c012c4f0e519c249c1f5e30eccd837b891a76c114e2d10dda692768bb1b8b48dc6a8c39a5a713b13cbd0fc937b6a6c72046c56b51b3648a4264b0b6e3b4d0254cc3346872ef4bd8783f90a6722368ffbaa9711108a0fdd56e765dfec3c288f0d929c8fa5423b4ddcaf16a07c3834dead8b034247bd3848fbc3b476a3ebecbff02775c0f23071d39ed95cc60f71669de399b835258ff8ef03bb5be7694555390b11297c804899be3d4d49c5cb44f62ab3c8c82cb4e22b1ceb4447f23386013c6b3286a3e9be20a2117fcb8ff4e490092f7bf288f0a20f4adb207e124f4fb03e7f4f9d1512ad91b26e6c4dc88bee98b3bc1881490e335295b73c72cb7745ad5eb66afa5b24590c107eb0fbdcfa9dae149de5818695d8e0c902f86a741575a9ab8e94ccb11c3b6f58608a17842b3f7793389ce7fc579cf852ca9fe228c82e27b3ee31e01ec063bd72d6383388c92f3b3f50c612995d9d66f079f4d1f87db0daf51db16bde1b32ec2d01f47487747a6e0adb7ad2385afbd1393c1ab647c72d7e5a9c58f7d1c79199037a557a0de402732fab0a11e14dfb729fd55677e178da32fbe411d9cf0a4631ebc7b2293e071f8bb26f29c762937edb113986cb20ecff656386a06b0d25da959dd048e57d5a6d0394dadbd192c164b82b867a34c6ba763e5a937156d3047af7ae611681076b2f93a1b50d87179ba8ff30d152cbe830c052f9b3bef4c6d2c262ccb560b4cb0d141d4c0d01a7bbf3a329b756d24ff1b1463bcded4018d6bb7f2d8ae833f8eaf0c1fb1fd72188901e292978cc1bf8e9f75fe36716a2700a5603aecb984864f38d0d4816a1ed9af599a1ae10e46e729dfc815872630692af9b3c1cc6cae647f566ba3da55793baf4ae6bf4bbaba04ea67446b0b540a08b4ec9ff4a48b6c56c33a3647ac01367c787d9023f51bd35a776c7206b4047e3b135c48db0eb1880c7f7888cce5533a3d2d138908cc39d171810d0c5b03e4605b918487af3f8337cebfdad592d09c0221cb240dce2000e904d6dc49347fc2f87f203b94c0193461d3b8118c31c7cafd1c7dfeb9f9e4c01fc7c22488f6f92f7d47a0542ea07d89baa9914a61b08e285af35c78dd61dae410497508c8a04fa03741632c5d3a5db68154f49523310cac0f6929547225095ababb7bf8559b49103cddc5f2b30cb2608ad104eed3e2de616b2015742e7a570c25ff1c56fec6dba1f648b9cfd58f5366eb961250dc942d717d1a0d8eb2ef2132f4142e642f62cac472e4413a637703460ef166e0df48cec842556fb4f13aaf5e60429a0f3b8e711c99b27c403ba0a0069967490b09492581c13d682f2afd1676bf70887087b3f23313b18d89f33695e8b1ca699a07cd0f7f1a96de8be988a20b5ac314e382fdd2360fd79cf39c5503667648c9bd5c80f3fb5812e9d63bcc384ce6352aac5bb0831812931f027a0895eefc91d019298a6031c7e89b7e6c069f0f7e759173bef8fcc6f5e91a3438278678ad3d8bec11a965147eddb9253824e0b5859f918f96109875163eb41a875c18075c3128476e19d6fc5faadeeb4af9b35ace9949bc2c92e973b29a4a588d7fbbca7c62c8ce2e7995b2955c9aead0e0b21deb4bb733460ffe4827b87e13316a8d43aed338a8b8f7b065fcc90e1b3212ae0a315777b7de8172979ed3bf397e4afde793748b0257e039393de9ec71a98420c79de5ee9342b32036d85c6a497c2c28c57a2d30725aaf3f72a68f636991c9e0f77f4543bca1e015dc391135f93bf5802112d47873d4cb43c1178c335b7dd462ce08ad4442d0d6d0677bdcf47de0d777a5e7c42be5b485d945ef3f8ba1cf241a617ec35e10dcba64575297d8106e77ca0a591a26afee0a9e8ac6943cda343bade3b7dec11e07cdf4955c84502d62aab37b1e486213f6ecdaa83a3c25ad5a76b327f766769f61bd0cd5e70706d5ea282f8321d095e0158f7095e292849cb9de342b14d97d7242bdd2952c746a412d30e718e234216553d35590c963de68313ce198f69e061a68c829365c2035fca0b46d435c9d594602d4da1c563a73a4920803ebf2105fe0177eda3b41b2ec9883b60ade4d6420be5641318abd9ded8e84dab9c1920c885fc262991bbda801fe0d3882705f2cd5230dc1edfbf6915685bc54e0f9d8f81d5e9c508660f795e9b6e668d3236e9b1c52398e3706ef990e05caa10e108e5bbf675628fc948e296f72cf45b6e378a2ee14718bc1f61c0f851838e94659bd050ce264139c44f67cdd54d277a9d39fcce66489da0bd705c41a0f515d0038fe5e60f576215fc1a160da3374fcd80e386d007ddb194e9dc9c989f2aff0c5906fe2559eeaf78c5a26f6fd895de0a97e61a9ce45cb8505cb3858063cf8f9d4ca8f28a3351cfb573da7ea7e998d15f818cc3c7879ef7b2cf58ba04a9b23a665c8e8b2914a00e05c4dc09ca60f7b157404f7c528a8f51dc2afd7345663e68ecbed9f1d83dffa88d7480ad2b9a9dd8b7d63938824c4747a7a415d5969318cdd439b7e70fc49b960cf8dbd503813faba64b30d1cfc0968af5550e5fb96666addaa5cadcabd2e3708b31b12f14920c6274712e7dbe4117716c91e51fe51d91f1f0b01626f26801d06589e77a3ad7cecd154c2a9d47ed49e9d6c6253292c0c46e23386f59db905edd5ab2a24a80188a2b2237796b504410524085ed78fa9c5cafc7e7bef9833bceadb5a195e399953b81c8741fb7de5fa4eea25beec168ab9ab2fbbdb243227485e3163b4bd6b781ffc9c470076e98ca58e828e999ea7ea63656f4382dbac4c3ba707727c66fbe611178e65be73cab5f29a2e8e6085d75ed9d3de28002bffea726691387d1ab8bdd3f069c1a81ddbdaf97a23551a384f8bee0ab1cb3c3d911861bbcd50431998441de01253ebedb5a3969d70303d4238afab3e85cead76382a7e0322f93408f8e967d5a4a320526b68a2ed9e7f0197dbe5a558a6e86af1dcd132d6706caa8d8a1eccaf00b88c49c8dc570d6b08c619c9b898ea15b93eb24723c7bd3e9c6d97096019e143d610f370649c4dc64ff25adf89746270d5ffbf8d6279c2d4648a4ed2bcdde7df047ec93f8662301b6b613b945d7df7ed85da151adbc2717cec2352f0aaf25ab84554ce9b99c39bf5d0cee17a774490effad2db3e219561b065f6b85747a568ccfb21ccd13be8db070d5b3bed19dea3db4ad9af6f0d1b3e958072b9cf813a8dfbd20e2cf373d76424604cb2432ba43231b37633a09e430265097786b1f39bf4ebac57ebfccea819f7f19d657e14b8a921aeed9a80d7a4e82e15fe4c421b0fa68cba2c67b3e44bdbd0b1be9845923d9a617edc83d933f43d57b712182ce948109f425dfaba9469d63033fa45223282e1d81904c3d61609caa6f1657b9e7c8bf47e901cf13a1b546b44bff19888ff8c55eae90c7a12f76ee2f1ccb692ba2cd99ebb34ba9f6ea0ae7c49830a7e3979f96cc1a1c5e20cd199f4c30881e07d1c622691488607c8dd2a33acac55e390994e17260e7df76d7eb6b97aa651d00f8bafb1f11f0b28423b8135170b598e731f2b63d927807016fe0a4183ae6a6e08efb3bfbdd075cd50a2cdd1b717e920e8d7ef29c19045568472db5c2e73c973fb8a76945c8df465ba6e7a50d2a6187c6c350b11380fda57898b05210621188869b5534a","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"3e989e1d93d4ee3ea8529a1da0f241da"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>

<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <link rel="icon" href="data:image/svg+xml;utf8,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20viewBox%3D%220%200%20100%20100%22%3E%3Ctext%20y%3D%22.9em%22%20font-size%3D%2290%22%3E%F0%9F%8E%83%3C%2Ftext%3E%3C%2Fsvg%3E">
        <title>FFF</title>
				<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no"/>

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: url(img/texture.jpg);
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: url(img/flames.gif);
                background-position-y: center;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: url(img/stars.gif);
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Your password is the key to your internet wonderland</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"4514b76f42ccd36d7bf5e5c5fa1968f8d92bd16791d088e6a0ba146ad303a9bbfd93fc67cd0608ec48727279e63e4dc1309480d3cca398c1934f6956e934c0381312015f29d9599b9cca81f80a01a45fc8411e670acbb2eb3dfbe956f380f1389db228d73958343dfefafec5be4e18987d48a225418b0f4881438bd7ef7c493972be7fc0d4d6e55563e75099abe207b85a8bb5d9d777c1fdf22c976bd025aef2393a8774e5858e7b612a856a26e35ffbb6cc3edd6fb740cd2e948df0a96e97b0ad8c7e63534457a9560900fb5666ce2489a2779ce36d0f3694b4f019a2d6db32bd81bf6234e11181a5f8d5666b408a120ef9f72d12ac9222063289481a9e534f9b8d2cec511e5a4d351ac6922024aa0f4ea4873f25526c73e18d8cc2b61c2efcb7acbe20d1ed72dd1c378fc32c72a5c24b9c091a0581acd754b55c56c751fa9ecc281828719b58242774b7e6ce9ed1064c0ba56c063f405382d366a98f3a7d7da941996b39ce0240f780e58304511cb717b12c665b15e9ad6aedd31f821ff31e856ab1789c1f4471b77ad7c9091c94408b5cd4118bd3efe4c6a55524b6205d762398dfcef6d4e980e254129be06c5cb5a1587d48ace99b409a42a80d871c404b246cdb13ec689b53de6fc5903f6fa95dd6dcc312783776ef674f32cf572c58bb95b12b067bcde8b6ce243a16165a316bc9ae752683296c8fdff16609884a2424a2264bc93dd98beff5a18bf17b3a5c7fb56c82744b26ae944db0d455704445810d47f931c429c0dc116faccd324cc3152947d458774256854111d477bd8ffb36f1e8680fe5d3c8813afffb5562e204ffa2327fa954d167c37f069c8ecfe4432e9cd1143a5ca9fa1e1012cdd4afae0544ef5b0f2efa77c05e45519e3ecd2b3547e63b4b3b5c443e42523c274ade84cf8beb1238c838fc5b9ba200b93936b888f4723cd11796ba598a26babd7d97e2a03993aa8d7b3a1dede04669b6fd7b0db547c1723138751bfa5a842347c44d04a6c3c377156a1c180b058f032aaed908e698a1b827252ab1e4e15499f46afb28691ddfbec4647bf5053bc6f4a153bc4216bf4d06ef1fca2a9a8e3b4770bc2f1ccbc6fa74cff4ec0ad0321ce93a8017f47026857f0427644e9eb0a0c4c0695ff32a06306f0db385939e8407eda6f0fe9339a4df2fb8db11c98e751f749da07f1e537c18aaa75b152ea96396d97424bcb3f21bce7803c98af29089f753982704cfbed9a02179834e570874c3c436efafadb226b7d8469981dea3b2ba239781e4c650467ec3f8774aab2e0c1ca8e98310aee8b5361e2ca4bb2bc98e1fe3f81fea43d9d8faac3a4ee32e43f05687bee812b49eb7cc9c82e125e950a4e530b6baa85c8452cd216cc15b2f9420b138654a85768451d4a01ba7f2d74d96bfec93aaaca516875779443c5da0fbdb1628bb7baf1bb46f66529943a3be759af126f916dd5619ac82a3bf9af45396c568a6a91ae896754c071f5bc37b3a7a07214eb691a98f409df776ece8fe5ccbb3ecd292b379467416514f0f413cf228e7314d2e2c9e3dc1d3fb67be74ba86563f472ee32464787acf55565a707c2de4558fcec9bbcfc5c53298c592ce68d69156de443952185aafa40a4882a7373a8711c0e19cae0ce0dfe058aa8e50c2b7d6eef584651de1cb67bbe5d21400290defad933d8f2ded7db769e6c91a790f7cc93dc6c3cfbf84a7525d847eda2e4c3bbbb7e586c8b93034fdf1cb36b4bbabe3c253e8d278fbfcf6a2dbe47aedd0953a39199a6bea8394344bacd4015a4ae00bae9cf327916048f2a3f73e8e74fbc6feb14704d35d4279cf6ba0f24e26df2a830ccb65b2f165fba25d720ef88c8d51fe43eca3ed1ccb7b39b5ac6c1971480e721b240c3b09b741daf43058d038e8ad003f5a44f56cb441351c74d3fbd53f3e4a5f56b58c9ea6bf664cbf9743075f7b894e27e7e40c4112c802e1b5ab718675a654361e6cd8fb3bc0213cb609c69b3e8ecaca2332c88370ed921298ade58493a1ab23299e401de34dbe16bddd9a2892e02c7f8a878a52d296b7b25267528044b04b28e9bee1ae0781c3398de51ffc57a41ca2f749216cbd33fc042dd7648ef629388fa72ddf95b9e1bfc7da46a941513f49e06402d1a4996f8bd2a0b4a1bc23c067edc10dd2dc8170a2465d4a0400632da94ebc801c4312c8391c8f4ef6320dce3b97e87c9adbedf40926275a6bb379b823acf86011a63619635d88d5ac7b7c2b6016afa339bf2e4a2dd16964e54a472f2d2645e22428c0da767a6a6cab69b3faaffb9065ebe7f8c98f1aa41449ddaba90aec9918089d93311a8468817742cdbff89c1e88c21f572647ab9c28fc5a51c728490fa4bbfa04f70f05eeecd67016b3acb0dba27f19ef51d523bd99d21113e0e0f7441c5369f075273c3d62cf450d8b45ccc73f9dbf9549415e441ec53fb2591a6961d670b9815ced621bb6bd736e2f8b563fe32a25b1237bf073964a407442bed6048312ed73f6ff90aa733f4085381bb150a821799f6ddd496716a1d3f4660094ebc0119f5a71920683b487569ecbe93bb9793340632772b7a022ad9765268f09f07676ceed7151343f68e3099f7326bd09ce7ab9e7fa873d5d9cf4659bc628901a3c2b4c1f38f46cdae6fdf393ae4e8f353515913e6d117556a738e156f713b31f33fe3121c10e51ac30c38765dd7d26acd417bf190b7c842522defb13fe92a2c2bc408c0adcccdeeb9b2a8e11b0386f796ff3e366684a43f444b6d717fbb969c1f1a960b1128ce72db3c1c413882531e08fe3cd0e9d1f49f1515ec71d3cb771bbbcfc389ae7c4323f7f659836722ffe96a1bf4ca5c9787340ad11cbb29cd55eef34d23e1af494121b550121743827b6a260945c1d05b49c3d125cdcc97a3a6d541ae0b4abd2531d98dcee4db4e7384601bf04c97d90336399403976e7a8763caac07b92f1ab6f8283600ddaa5fab90ddc2bdfc7b3aeeb476b49566f76c80e6d0ca2b4c197f7c095e4cd1cfebc2d990a7b2ecae60afb72a63a6b2e21a728c8ac6085be260e96ee04b41456ec9ebbfe7fa238e03b1f9779fe498af962863cb635e21b65db911c5a48e259f1ed45e3d41ca5b275569eb8b8c24989363967dee4c816da9860267adbea48b0ca0af38729b797c1b8665c9f7404256ed3fc6bc4de4372b81bffe104606780164444e987006fcb99d387dfc126dc5f7254ce93e5dda8d4a081f3198dd0bac17a4e11a7d86f1004a120a3cf89a85da4ae26c41d7b439f34547393a43cd09b9b460abec08fb1f5394bed79a99a4d2e3cfcafbbac6a8e9e7b8af5e6a523a5c7faecd60179deadc3ce4e555956ca76a2497ae50102faca0602b1086a0dccdefcf8a8334600a95fa4847f76bc2c0f6ef70f050ecc5af76a927f65c6748b193525cf83666db7eade965ac9d794dc6cba7702c583b941ad0570013e3d0a546c401cea8426d78ea31bafeaf5ca99b434759fd1e36f975e5a4cf75de59a340d652e0991dd5fad188908b6e19115ca0eccb6a06e5262d3ee8a11c1adecfe315ccc013ed960207fe0830fc0a4fec23c57c8d80f922bdeb97a19ea25000d1515dddcd1dc6eef9b30b6b4091b4949dd786ced46665be964aa8ca27778f40a6edb3fdae8394a706f8f962f7a059a3ba8e3ffa0d14753c35b4d766038315a1ffccc4eb4393f616e242b21e2c51db0a065554767e6b11b20a248e148627f1633d65db4032a74af5ab9a84e15a02212d02188b14271098bddca20e61b2e368ae1e488bcbaef8d537ad7d6425ff2f922571aef263537c6c145a93a82d7f9896296b054569bb6c7edba416c0acdd9de8c3beb1d90f5eab33e4af12f90cffe165799e70531173cc900f805a43c6bc0524387172f55fea3da8cfa6c6356bc4765b5b4ce07705696e1bcee858d40e75ea0ae276e069293cc96f65963ac376d2f57010134bd54ce059edce638d0063fa97707051955e880be4d25c5ab3d2af28185b52d1e06f9c0afa6451b576eb04e63628490767dd3cd98c6fff006f2649b2306c1d7e1692ffce07343321f60b324169c637ae5869a2a831e47c42e916e20f18409f6e2ecef1da4fe993388582791e12c13dabce20dec66632913ce42e5e7934a2a1a96f4f6a9a1788ce388936952697eafb8d9576a2ea506c513ae2d46d21ab763d426c361bdea6e0cee1418be58eb49856a10f9c0f03ec90e83f43a9f43eceba46757259df6c54d4bc172e7ff943554dec8328c6a020973f34b8161fb7bc7b840438c4e36d52ab0ee6fcc6289b06bfcb7e0d66905ecc7f30ed8e62ffc4271e7fa8686b9bd77c03222c44b48973ad021193d588aac5d64363a53385cb5d15ac1b243a1c4750ae3ed42464a2e25b58728b34eb4d29ec6ce81a825082f6bda7a136d655f243a712d47ad520df388258985ed0311c62d2405ac0d0a8a3ad42dc317f11f2f7a08628ebeb78b8737ccbae47dde090c0d04c1ba22239e6093318e5d4430e9cca8c7839c1e794411b76305f4fb2328849e445114ebe32ec35a6a1be54535c0f703d0891a703c083e3f378a2975b39bd778bccb51ac175b13c3050da6861af104af71063bc0184a0f3e2cfcb66e8538f5db8712ca866e8d02e35d490cbeb7991f569e3a520cdbfe82c0407b4c00d9eb2087f1ab6dac58ca8e248db27b5d260fb368ffa2f06720e0bc7b2da5ade4531703c8aec486c288ed22a40d6d7de145ccf807975ecb83d11ba803dd501c54b574d94449e008b88ce53869341255f7ed920377fabe3489dbdf2927c45811c529f55ae38cb62b45e96b8a5e19025f2eb5393e32b9696c7e36903fe78c9e53412093ffda4b320091ae456103ddaa6f0648fcf92c676a273b584433852762acd4779e252ba9bfa9eaad0e215b0712a6f53db5543d5be82ce2d1951d0b89697c8f8eae2496037f1d5e0bcc2cdc1633c0ba09547964d111fb5e6f01248641dfe6fc783ea9a46981a0c782af66e5619dde323525feca427af5d4da720ededb96154fb9b2f7d43713f36b3a60fb506d8a0a856418e15cf4cfa77a606e80669e1c6a91b06640de2b388f0d575496649d0cbf18c416e8c12ba130b3f108c015dfcb747a3a09cb867d5b9a1e3015034b300359027464953c76555105017c3841824a7dcf06fbc31cb3ca6758d7fed5edec7cc2d5ae9ade45b7f8f8c529697952d14feb18d6eaaa0fa038102fd128c899f66e826b3ac4f96314bbd08910b075c68246e55864c82be441ae15b35ef4d2cd619e019cc687fb763d21826aa1efa57ce8ad7616361368f78fd76f631daa78233c0cefa2ce2cc43d36a780516237a245971bea4f12ef57c60dfea88400f893e16589c21bfd9ea6f1f03b49ecff9fdf03fa06be3c3f273b9800a7b67faf304f88cdd91386f18877efca95d00df706923c3d0e4519392d3581689ea9be0e39dc9c040c161d7e2e976dfdcd4948774d00415509780a8595bcc4c95e422131c8f03e1daaa3d459ba2515ea2615a6de7e377fb6bd7f1f88a2b4ed381af7fa38d2c5230d6bc8e6e2434085313bbd2823c639182f3d13b5365eb226ae5eec7140047af59df7cfbc921901bbf30442e05357e41491e9b3b0d78128e077cba2d2e964f63aecb3b33aced3f155bf8aff7680f74bf21a59d066c99430565a7575b96f17afd46b59f49b31b160db3bbc3dd9d67fc691d39d66b4cdef5aeff80e43b1fb5b41abe325559ec657122a5f51fdca1001a650c6c6b30c7e31f730222e142a32c5be084018456751e8a596ae746f40f73ae2bf3e98a1240b323002aac410a6d73a497b0169453968dd796f11938082eec3414c46d7a0aa427bb6d120877f38bcd8d07481aa0f2ea84ba8e8c1baef13c2ac9a62bd4d54a8391e90149f8469a67d29636127381b9ae7db3db4a38ac7b48b14c40803fc5decd3c6ade444ad595904dcee22ba4a1130619a1f6e6946947d0f2a9a0414fda34a426f8fddaa286be6311011227450d3a70b916930c52ffcd2819b4e718cc9002860042d4f87c6165a5a3b2d4efad95dfe497052a87cc13683a6df92f234d571d98e0e98f1e992e2e3ef21efe8673c77dc3d8aaa448fa9f90955241a996fde4575c3f335ea311c77e21860bf4fdb514db6e973a07d4c5226dee6e274f38c51ffb1ad2e342eaf5fe7e0be49a72d0359f910f89c6d5cc67e8c3043518a7154561a81af14e33ae63a45c22e07ed2d655e16bf174a7688ed86cffeb95064c38d2bf9f446fd90e5687b17deb69058aca24b5644019a189640cba83edeced921d763b2f73ee0e3165eb35eed8180c861b0006ce50a545a1a10463a3dfea6436771bf43df5cb0472bf4d0f4191faf1f2d874125e06cd49df55ee14b3c06813960367ad5b3551b695f7a417a0dd6155d410e0981d9785b0af6afc50b73d5df5460d79cf21e105599d321d2dde7ed2d4c6afdfa5313b289b28c98993e7834541ced27fda81aa88c42c56c3a3c840af7f178cab9eacfb240b066f1684f2e49821a31d9e1edc971c4552e9fb9379fe75824e3d8dde0f74b9b696ed23eea2ce956f1f02583e8495fc50ff2f8ec66187dfeb268b255ab528b692abdecfb3779e9bbc8c75e6863cf8f08277f494c2d0ab1e84526fadde70abfd56e5e098dcfddadbf8d19586c2a2853c1131cf0195e47d0a7053045fe0c76d4ae92bafa33876e0871c66851df9a7821d91d10a204438261149deb077031c517b6b473ac62363ee2a1ffc9cc22f7aaf23592c7cb5fcf867dc174a6e6e10b939e8caeda9cafe4f40479a7d8a61b693bba17d62461e68e1eb4f8d226009e5bb2e081ea6f2bd92d4c38f6b121b3b8d94f0b1ea589e06476f809335b6de8e1afb3408ca2125f76fd548040ac6f27c2b8de1c0e02e4b301ae98665f5c932a9b0323343801e779e18029e8217b3c819fef99eda3df30036a4cfe70ae89c2f1c75fc5c57cd19e0812dd4bf62b04df5e2049629467f041ee22fd1bdd7f7a813f1005b7febb686cb529f323e10dddd2a7f8fc776a481322bfde4c1810306a59d78f1166ebadac3393b8c2b762818069ce713beaec8168f71a0b266ce472dd6d13a00487a37cec8cb82893cc61b7db883e95bf09e719d1fa4385fad555a6ea192e39380794e61a11f2f960acfafb6a8651669c9444cfed9dbd8c90e48b9dc48a272c3e5c8fbe8711a9da303037d6f7e0634c54e956d68c978c73175366689c13ae083b5784e1a91d182c524a2daf9ccf991c08127db21be3e1c2c68d06731b4a8e3d882638b37629bf0a6d0fb45b5786eb26297fb6d3a1b7c85bdd846570f73fe0cbefd7f548c3eb8a9e5a37dbceb1fade1d7f5a28f4303e57bd4a581178c861b8b75f6e7e9b4399485d810735b2c11ff193f01c9c1f9564498b0a55845895abd680f1434179a325ce745a2bb459e1e78a29034d9193eb32a8248facd2354a3dd7d674c8157f435c7c34951936aa49367543eb162ded45cf1bf49a84528b3a64c52c54527a2f09fb92082dea2d0b27fda081058a94c6b8107d729de4a5557666c270ac6be500e8787e4074aa2d113067c9a2ff8e049a54d9aeed799264977278ece5f93bf81aa9972fa0352e67571715537646c699bf20f77251baa30a2e66aab12eda109635427c20a77f5010bf70b1317757770da92b00b25f2dd8c0cb95b714a6c60f02d8c60d3a95c9a3b2e4c8eb2b60b5843ff5ea715bbe27d00f640dcfdeb42c41e4e30237ad7f2a3f5bc81b2a9a308adec664f6d69359e8c9e64b2cd2a04bd966be4ad6f3301e8f3a1e6fef43a0a606f030774f5a95325869bf4a7004e12aad9838deaf23984abb07283c8f0b817884f387f00ba21a870c8dfab68846cbcda9aedd8a84192b9f792a01951d0a7496323a9c3dd1b75f808606e450fc947f036b0d3def7db8654aa6b1fc0e27abb712a2be8e837d7e3e8edfadc7c9f33c9e02b61f43603ac51bca602ac4ed7face542c016a04ef5972430627b2f57768eb25b53f0acfbf7a5d65b79619064a7926d23f86705037c25c170fdfca048c2cca6088f74b8ab380f695c6073435c2076e978b8e95c7a1ba39a077c98997ac7a3b03547d9474a471b8475ef20c0af377ebd5e662ccefd7b4bd892d1ba7305f6e720e7d2afb1841c2d58e21cf7e206fd721a430c57c927873fe06702e5423bed7f7cbdfff0d70797007b9a20f0f83d1bef3b217fc160eddb699f9c7c59e06782b22ff3451d8f82a2967ee13dbb69262a13661c2fd5fecb5f7b3c7a4fa61f541c1f20c4f90dfac20d8a0aa132f927da7f366be1fc42636f851f376920057732c12b6f91f1c421e9d8dbcc2096445d2b81046d359694dc70cffd22e59ba9a4dee2fa48f1d3ff67c85ec3005bf113549a8cd157393ceb9c3ea1c99093f9f17d1b879a8474910cdb14a61850522ff08ff2d6f02686ff4f81a7b93f8f4502a1b5da69e289ea3c1f2312813cd2ba2313561696acc37a1dda644384236541e9c07fa3f3c7c343fa985b30109a96fdbd4236337aa8ff4343988456eca9838f171f36fc8e439f7715d9840eb6fabd930a9eb4fec7512a46d31e372ac853f7ad3807be038872043c956aec1c424ff83cfb551d082bb1d518ca291f25a433611ced96ab696a25adc568766ea698f74fcd9db1e3796039cb85efc06ff51d7f77b2e780eaf75279e3d5c56e406cd1ce34f80fd19615a5f855db3e5d8ed363578c6a7db0438fce826aaafa4f39232e3ff316fb2e37411d1304f5bb89560b20f02bc682fb5d0ed9082a402f999259fef0effd405a34278eeb7885315c84f7e024566e406107aa32bf9932cd86f7307e4e00a44775f09c3c1ae73b73c76549f433f07bdc58ae92c3af63b2eecb039f75f5f1e7ddd780f5a0ce944a207861382a4fb8fbb452dbd99605413ac97f8432d633bad2fc71e065d46534ee005747f1189da68003fe02a44fd1bcf47b14a3d59e42c3b0caf815ab2327098351d7001256aefc6aec05383271b83e78c572b34d29257231c5c3e0fafad1a1273a791fac08e3576b227f24154475aa2acd27eae1c874abb1063a2f6f2e2b8b1aabebec9fe5b7b480064f57f51f132b07b364720da9cadc7cecaf999e8a51584150d14b9e84fe48d3371bb4be4556326c5d4a30c84916b81ef169f8054a4b760816312f7acf9a2d7f256bfe5cbc4f9fbbdd76c31342f44178be9343a47dcea624a774425946fbcf10bfe58a3740def4d922ac9cb3cd0050b1e3048a52cdcda6b6317999ea552889d8a417c7674fe53a1a775eaade3ae99529c1667ab9d0d538cc32bc19df161e8774670e4331da11c9a29dd1ba4146e39516b9127e746729ab97a039e1b02f5b323deec5bafa772c18594a1d2c69a28c385097d725ea68f6e4671e16d8240260c5c59f6a9c03f7d7cc0712a2721e4296c112b37e28356e2644d9f3500531981d3e73324f6e59659183a3887a9ef70b3e96873c475769e2d1d5f835757b82d9393e49395498013f524f746bdfa29d0597bf16e03254ca672ac7e4b65641e2ad6fc4f3cb60d849704d6b9b0bd3af05cd85de3fe5d8d9d97b53436a5149e88aeb21917cc9adbe06633909cd61d3fcb2d6576e9d5b3b58b048bf7d60e625b7756e4d25fd2504b3c512fb4558f19dbde8661ac6e0d839c1a4a23adfed6def57aeb946739b6befd7e4603ad45553f3eb96a84aa26c99a053811be7a87be1ac0022aa3744d6e1bfe191d17597ed0a7e1d8245051afe592de298d28a718445ee2ffcb25d7d7ed78c3c79ad2efdac64fed29445075db271d760d8345d3a2b9f0dd583a1065ca3e90831ba3d311586b9e5e151628699bdd9abac35d17b73e40507ec99b864cd649a98d14f0174665f1943002b713a1f53dbb1c6f44bf79254e15ba473a8cd9ad9959c569eb26d4a474b3d362955e6a6607fecc5a86a9a0d29541fb6ad6f8c091b2a2e0c7666372e914acb4130a67370b879faecdab9820c1d8059b67ab8b026048fa761406f4507be66f25b84231ba78525f12cf5f19494bacf0c68858ef9b0194c92eb924999bd800f3193bf807718f5411338350aa94fb2881356c85e59578ca7c576797840721a3a94330ea5f573d6f6cdc9e266da7f6fab432dcc7147e4b8303d9df09360e4621e28738b0af12ec714cc4fafcf5da76c84caf468ffacaf21ba7d146ecbb02c27ad3b981812ef5f149c374973ff056fd095c226b2770eb40f15e07c21606149a5913b5a4a1a4458be099888fb8e89c2d2cf6e8eb1f872d1fd3e806f28a5972a282e2377ad035884e359fdd7a6153eb14129cbbd7768fe0e583324be9b3aaed01043e97c781ee2a8a01af2d72b1500879f54604ec5cd16ce3cfe15b7f0393b8519d4101bc19e05a1d3426a2c02a686b5c5fac85140870c4bc274f8d21759e122a8922f0f7587204d966f731b2d7b1dbd303f38190b19fc88e75798da1a357d2f1a1382129c40950b7df4e8e34eaca0be89fcd7d02ffa86b73c20b34cd8fbea1c985b908cb87f5a75fb982c847bebf7576f13169b9b7b5ad0d820139ae4b7458b72e7fe3cb029bf51a65c6afc3e6ca91e5477761fe7be5789cfe3c8f9490e226486f236f591d75d8a0cf81c098f5ba1673f7288274fa741d87b1c7389daa1a0ccdfc72ad3b32f80ae67dd5f1d6d8e0d893c13b88daa582a7741163159dcd6d4e401383f8c19a33675488f6eb0539ce9d573946b560575b3e8304cd500f7a9d9141d2cb801c67df407d84e9004a7161d7f2e1569660acce06247791190ec3e6249574b6296977f0e157103c1fdfe40bd2cf462fef296daa84e0d68e1e66f83f667285934629147c3788e71c08905ff8d4940c9569b0f55680b01e2e033cf9ff1c963fe64b4e322d4b4bac4211944bfcceca52ae9b0405f5f76febfba12c2bab2087d808ea41fb30fe0c66c73e04da5761bcd6f9994b8cd63a196b870d8e304ffa902b807a50a2de0f4b96999c8a5d4460c7c78c4f2b65b66628b41c3572fcf07b3be591e634c9c53fb07b1361510078c62c69446d4a49119e21b12b76df1eb24011e2665e242df0c6735782e6598dd847534a637fe5ce04bdbdc182d9b3af64aea944a144db77821472cb13d8ca5a955b2bc5be0ff6b9b1503791cf0f60477bb66776dc3c0b04dfe40d4ec666351ae8dc2954c61aef53463528ceea929aa49840e09507788297d616cdb505a3c6885fd7700111bd4dc80b1361a79c2fe7ddddad7493d84bbd795a15e7014d095507fb0f5cb44c9e106a5edaf7e756566c924a6ccaec12e7172f46cd14add428a4380e349bbb3095c483d0600cf4a28f78cc640e441232e57be3ebccb1c7d3d6753e5a4fdc78f3c71da4419aed34a8308684f95a02494803ff6b94dd467d0137847462636040150bddcd2019f82f931f0a064926dbab16a333b2d0af677976508fcc7767dc0c616293ca3323c6835dd4fd3fda8a037f82fd66e550551dc502ab3a0bc0a7fb516cad31e2909d6c61e62474228d8b41af3195d96e51da1c43e2cd47ee2e963aa91f571b1d1ebdb0b3bb6653fb0822e1e05c7f9d3a776d5b567b1c1d09a1a291bd3418da910471e6a44672f2797918c03ccf1dfdbeed0ff5f62388cf02e6ab38ea3b298d4da2f71602548faebbfa1c7451aa6a1f232265c40e26589a0eee96c2d10b408034b0e26c0111e882770b68241cde61cab68e972264a0d65e2421919ad7ad5ad4d195508593348a96a8f0c32ad5264a4e7558d51cc3adc16f4a817c15807a9a27119a6c3e7165fa3a30e8111ac82a524b370615b1e1a7525ad9a9cd9cf829c6e44950ef121d88ff6e88b2dd3e779b656f528f9cfbc9f26e19b0a310fd599f73b3ebaa60b12e4ae6382809b07eb996889885f1a79b70c46bc5ef9cb8680f14e9319be065205e30c0d6a30c5a786e21292a416f0ba1b7ddb9e2b9e09bc4f49dfe3f3e33b540fc86ee977b1f6c7548d58a879af0571d9dcaa7313351c8a7dc2976deb955b30746e9772e9f379caa4811e841b37cbbf51e48cd543e9f57fe6e9303a4806d2b93d8f2fc59f754da08bef9056db5517c568f85865ee4f5172fb114ec3b8f2c2bf02b61d690881cb63842a0db308196b6e847150257fd5dda569e46be661538d13eea61d22ac29ba056d952a1a134ac383f08a6513511564a1b7d287990c66abc3bb0cab7675ff132eb17f7892b88b6e95458561","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"dca57dfb13f3711b1baba6bb2ed6bb47"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>

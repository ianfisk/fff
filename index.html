<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <link rel="icon" href="data:image/svg+xml;utf8,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20viewBox%3D%220%200%20100%20100%22%3E%3Ctext%20y%3D%22.9em%22%20font-size%3D%2290%22%3E%F0%9F%8E%83%3C%2Ftext%3E%3C%2Fsvg%3E">
        <title>FFFF</title>
        <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no"/>

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: url(img/texture.jpg);
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: url(img/flames.gif);
                background-position-y: center;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: url(img/stars.gif);
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Your password is the key to your internet wonderland</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"ec7a0da48bd1c3085263f4634dc687b091d96b12f13e6dd57c99d7d2cb16a89f00107199505d13e2c69ee3c5e6676872aec05b60bad421aa707d4b2d54950b8e259bb226009884ed1b89b70c1875e8baf19aff15a1c60c47731565a9ecb3c5cd886d5ce7251df89f9310995821f7154ee89d7f0981fae376055e8e6c45e1ca04db6e38e2aca4461689f8c6121cd9d7cec3b9ab247dbfe2f2d49f9de6990201dba3c8289536263ff07f129ab494304a1d28f7fe04e093cb691796cde81ac6196e27c1c0fea25e44564a902f6394a8e466c5b415ec18b7ed1196dffb03b6a98d51cd3ea266c8f95907702284f6730a90f1df2cf99fdf2bcb18a1fff624a62b5b72bdfa60114ba0b3d31b3f079b1de119d5baf33276fed7d40cd9a7704ca4dfd0ce296fcbf6fa9dc824a6daa667564db1443322ea2bfe4ed920f68835f79247cfbba450b6ac95711a63a30f731b5c5a5522633341e987d98e31cef235dfccd3a4431dc2a230785ab92b80385153bae39cd126a5f29ed78ad5e3e019d10dac82c1be36044c81eedc2e5cd369c26978020ef8ef3db2c806cfc5d76c8ec877d34d1fa07adc7d9eeb3468ed2672af4f8ef2caec5c17848eded912164b8a8b383780447192f738ff9618ebf326489d2c8644d4cb661c7619f8536976a2edab8b547b60db3da7dbc9a94d4bd4fe662c67c0975b88a7fc4954b18da2f86fdf2287d03ab12a747d7dc4a446285446fc7bfdc0173c8f6787e672485100dfb6ad3180def64995f3d840278eca07ad7e08b71560cfd0e6640722c7a4152e4ed6f92331ef8deb03f7cadba141331063ae04447cd3b497dad2983efef49f806f233f195d4d17c2d2a49872e4aa3bd6fb4429d165b1f6b388d9cc42decad1a6d7c7274202cfc61c8ca39bda8f9ddade776c93aee624e7d55f755b6f612cf3f16ef7f37b432101a217152ce07bb51dbac285c005fb6d7fef9bf572cecf2cf495027ce7baa1cb5a2278b7cd960c271bb271b5148b0fc51673cae69f9f3ebf4221adb92cc33dd83f2458d024f5c645e1fe78b834f124687fc373bd4397fb7be2a7a4747186048f134bd55c082bf36258b39b539e122ee925015d172dd3b83a57094071dc2379e4d68be7007fa17894d190a9088fc4fbd9d9b32b4f97e42f1e4d765f9a4c3f12168111b21c58c8f0405eb059117e6628963501eb7243ef35c5fbe20ed521d106a4b2fda96567582fc4d688bdf8af115b0036a836b07ab1de5f1083e3bc1ac58bdc038f2da8fb3394408f6c4c21c2ffd10c9ddb3bec9574ee95a56d21b7500f39498589eafc205afb46667089498e0ab422f994f96ca61b7105001b5bd523ae0602771c421d22f0a93c1613314410265ca91bb3df3a880c866bac5a7e8c3efad6fe16f65d5433ddfaeb5ece0b161e028675023cdb14d2ff0514e61f968867b6d6bc3463d28375db8bed804c565c8ec7b6fbe2c67657df3aadb885f65abda0790ed310e6ddc0f2ea4c731d6e05ea120ad0b4617b1678719e0c43134f34dcd6d62207ebae1efcd389fae5bc473389f332066352efc360a4e34a69eff931cba9066baea8b62b0def91944ace17462bf0effbbba424cad5b43dcee63b116f2be33c39c85555cdcb4c2da96997d8254a5f87c4594f4677e4edbedb5dc3230a515ef2dcde61cc7ab2374b75b52e88e6b6c17bd91d9d8aab08fabe0a0d69c95242b301fb79dd0f330fea5c5acb0f7b3f16e8cd1a402dd851672ae58b032dcb4595491737480bf615db6b3d9a992f3e3f26ba08b64eaceed688db94ef998bba454c87df119a8c55872916ab5f4ed8cdc6ac7c82f21c3aa6645f3ac0f798d0efa62b2563933da3c7f6bde0b5801b21592ef08a3d6a3a7cee7fbbbc007ae25eb6f0b72e02a26e72ecc14c29a1d4726e74be30fa32c58acc7d678ccfe35ec41be20ecdb518ff1143b3a19e2c1999443761c0fe54dcc9b9dbd96df4372cfd6b6d89aae6407df873aad9069423c2a3197e9c76ec1d964f6790e1c0900f310c49e419ec6abe46bb1420ad2a5ca34d98b1f19c42560e5b136c8ea4f0b14b27d9eb54cd2cda9119ab0f3bf1da15524b1c57f9ffa0d4535be9b9db7623836efb2bebb7f098881b6e13fa0f826acf9c7251c874d4355c7b7626a56f7d55f7266e68279a30ea239b4e32fc85f36ea07d2618306631e71542ab59c7f3980bd90a5d2ed38bf592681cbd67d67e86ec099779c7193ba2abec8949150394cc0ee3f982666a98f59f5f0b3ed979a3adda706570dc3685c649124b5b44bd2f2334cc55f09ffb0721b4601e3876ce50a97cab1b94028e8419d9997f60e6d9623cee9b7ef2c1be74254488e1bdbb6939b86ff2e246025c15e8c2021e5f503fcd43eb9a15df88572ee5b4f75de8bc30f3856735fd2d06d38db0b9d667000ee0b4b1ddf4a429231e06fdcd100eb9271aaae614f4b9e03ab053b3d01b6ce6e2d7c5a47a0bd025d4915f2bb0270a82d5c7caa79f0ffd208685c43198fcb8c7409d75beb50ab2384d95233ce038cb683106137b4b42572eb31fd94169e1fb07655d1d4967c515086df402657e9f38bf824e84cac20a20a3e1f127ec1f5b3a2aa8ef032c2c3b81383fff7f977c08c64297d53b28e3df17977529f1d4bde92e7e185d38db550521e5346478387ad999c974237140830b83a1f5efc6edf2040ec6631ecb204543121cded2c483c5430fbe0d0a195793612ac750c7343c6c39875f0878067ac8fe620d24903fd6bbb974ee7c6ef596708724fc8dde93a25edba0c133f0de569f1eba902cc3c8df5d1eda5fabf9786ab4e979d1581ee5844411d9f02a582a6cfdb9c25e97d419f833d6db07de6c1338e2aa8eef2c06bc06842c05596d7d5a2a3013a7fbb600b8d02caf54a9c8f29c40bd2d2a321724a715ebd1159222ca7d6d3004e67d4d6f76a5a9a1749bc16549df97d457682ebbef823517359740e03b78372c993ef7a1236f414ba64d202bc7a152ba3eb6687e6f8bf406f1eb9ea6f3b8a59e4d7d254a1c7e92fe511ee55f9a15600d215583927347c75f63e30623d37a6d4f754d40b81a2beb636af1f99d66d75bdfeede403b3e53a8a02ef362933c39d862fd42ffacbd1868f68555f76a86771ac01a2352a9090dc887c428a8ae151777f8d2ea090b4b34cf7788a3454c7db6a5afb31268aedcd389e05a2c8a6cb85018b215e2af5ae7a639ececa7fa5e981923019f7e22c82eded2b91b49efbb997ca62947e78b93e142ebe83584be7ed6afd34a4071a6492268766168376d5f92a59d9af7ec8f1945a0571bccde189b4c12eb80ec2921dc61345e99bb3c6b6507340a4ec45931893621d846add5ac2aeabb222051b1799664936204978348563f821fad96b9b7ec3b6f4b907ec43aa38cef8a5fc6de92413d989ce6d453ba56b03704b641e5b1f0f5d8518c9de511d4da8076614a603e9d36a9f40ef85c43c93f91d7dd98d834467737a0fd263cadb370c090f5b9610ee384741b0d2d1057f9b6c5d6768fabcc420293d29f7e71079292618023ab8ef0ad1abaaef0f237650afc3fab60c653446d6baf5509bbce9aaf681b9a986690731fc0b154353b5a45c3c14ab369077f8c80149844f8b0ee3a8ed2f54a5bbea04c3ac4cde6284ceebc71b4d6d08840e2ee402f8d1ec6cb9dfd5743a54a86877ea8d8a613ca4184379e2dc81f1fd69957fb366e96bf7c8e5e1624d574b88e9884683d7e241668666077df10a21234f284a9be131e8c97a70ff2aecec7f2ef6b7b416d510d6c661b605c1dd7d73a97cf717b7cc8964e264c911cd2eca0db2073fd49abf7f719d39f7c7bebc729b7793cbdccd93a711a98513a9f1a795fe9eabe021d4672b644bcf8e7ea9e78daefb236fb84ac51d2755fed77e333570ab08a35d9f14baa4f06a9a6ca289d9f00bb3d6d249f45a7089dcaa97ed5cc6a973f8a7f317fe7197561be07ebeb56beb4b915850be1640e683583537e936d2d87a2fbc8ba920d881da5824a632d94b3c45639dba3d598b15fadcec238ac356a06cc58ba74a16b7128b40eb001050e620efbf2e3cc2711d7f063089d03b6ed8155aa0f111cbf60d3edae273118ac958f5bd20b230a83c32b0a2f5331912c3e1bb3aa60f5a354280a2a25a66f891d88151673e118c7b7043cfc52fc46af83dba8b0b3e567bc2e9218cf241203824ddfa78d4fadff9a2aa4e6da96bcec8153e82b19a2c13a02f93a8da31632a3661f1de2b68a2a563f7e985fa2fd0834cff74b3bdababe033efd36fad63496173303efc6158fee61f6d5cf8d2d530efcf4fc1b566a2bf842309f3ab3d353ed8285da27b430fa16914492e1f0a5d058e96a5e22973622aab0022c44a40f9236802c1d3d0c65ad84fed585746d015fa1018b60c8fbe4a691e2e64ce85a36d3edbce959ca88312aa0df143147173a090adc58db99621b70bbdb873347a27149994283ec7e404330bae7ebc02d566f654337a2101ccb8fcdde8578fce0fc08f331cd19a02b066741529594b3b8a11cddc67577c81faa17b5075f68a785637ae411b946b49c96c4ee957b733fa1359e303ca455eaf9d61fe4a5cc5484d152d68dfdcb7d04b31305e6d6e5ccad849b950cd310b7aa0f185c17df2eac557cb185f6cc53caa86c9af841d3f1f57792845b1a357fba52a67aef1ed2c8b620b36e09e5d2d076c39cd69aed50abf97c5d08868db5c37944dc35adbaded5cc331a9c016457fb4d697824b975b6491efcc1776a1fbfe5e317a70203844283e9731a01fbe903a4cc1c6a04af1c89c77463a0ca854e53ef9861b832516fd6ad4f9b623a86ce9e76660f34a6937c1a1c70ea26a44924152941e3eec8e3a720b9f6543fd01855375fcddc03ffc0dff450c408e8a08b10cf0d5a830dda9aef781161d9d0ac5c148bd8332bd866cd950ae1d9d3f09e1f2cfcd1a35963074567ec73093316f783a676ae3c53362ae2652c4e51ac3e5841324cfcb80604fd8b09a84852bf23fb24d18ed74203a198949958fec861fc1cf78fc953ea0a59b95d4898e710584ed8f4078e8a096d654d85b4cce00ad8f3688d9c0c855c88c75bf3fabe9978777121f17d6bece364d947ee96e2755a0464b5e6e2724493009857291526cdd6e5452829899b9798910f0364c1e7df46cf85a860c402745f028d046b4b97267c76cd81fb312bdee31c9ca04b17273471451a399807a18fedf26df23dadfe862310ecd3df2c32ed0fe88f216cceff177962d19eed245ae79f5476a8d384737dec391c39d251489ce7be1b8d3411b3233bf1fc442d0bc6cdfa9aa4ea5c12dc1085fdbddc866aff9886e54b5b0695f04eecfce5ffc814bb0cc1e32c9a9b21011e90de4ec2863e9b9e6b37a2055f11f49a3c21e9ea3375bcdffc5def89f754ca08cc846f17ccefcfbf68e7c56c9c43e24700bba89989c190c4de2db848153ca5df153428a8c6c5d8e6f5d259a5c090863ec663694e9ba5e170837b60c4ef3112feb4bf550d95e1d7a3f3abc0640748d787e3f01e5bbe3f191ec7da28830684a511cc2b4412091d228fd8977c8a0fb281fe5a9a36b81ef7886b979aaaf68765ddf9d463de2430910bd6b17f59cf5489528d55b8e38e8b7e1797848dae696be821929724e2c7f22b09a27c57e0817cf26310defa7c1ed8dee00dc3a560205bcfa5329951f6136b208ed10ff51ee4b77bbd7ed4b3b86b99ee93357fb70de3939e24957c475179c24e6ee7f40d8483b7fcd1362e37a770268405c098c3321f34edef1198ec0f6d9bf5f7a4cd865be17ebeacd7108752685182b2b32f1c0da318b5f4585ae25e82c4381f202a31595e425a1a8fe548bf4a7e042fe4a465f477d4d3a4d84f36e4ece01c1850d34dc1f9bf3843f49d3b0dfdc41bf29e08675c94ee1596091ef364126dc67f9a034cbe29830fc86fc06276f9c47c9f71dcc2675570b396b61cd132a3527556bbfb713f91e3569f6a0f40f5dbbbe07debc444a6cb7e84f73c0797e8bcb6c3371464117974aa267c8dc757a55b1a24eb4d4be798307e8dc42c8eceed204baa388a86497fe0ad82dbdd6862d107c4cadd75d3b5c55baade3d0842897941f2097eb24b02882fcfe8334f148b46f16ad9db552a1414ec6392dea755a63575228a3c928846d026d737c9b8e86ec54c809191d071e6646d106fac7a5e20bacba256e25ab82d38b13c191fbb921d7312813bf159b3efae5484bef6615a910b64b9d409948801cba1b6ec5c4c48ecea3451418311f6dab363088f9c37592e5e0dbf23a382216e0b71613967a990de79dc8bf8b02f120f7560c0c41d1955d3c2ffe6f978166bdcf200235085cf431ed39f4bae38d9f0eafa771e3a0aa374fe9d0b0508b7ea8c714f8f084c1d626d6f3998fccfa6daf2c461c841b7e0ed376164056475cbd1112bde712f9cfc8135312270ecc0a0390f2d2e24130b86b9bb3b3664e82b43cca0d3ecd4178c911f5787c1e91174eda6bc4c1c2896f7304a86e44421fd3a9fe62d0c13826f54a6864a22b025d5629c5d309543163f96652f108d2f4046e6e55e7a4359bddac6132884df0d1034db02f1dfce304d354ce7928bce219e979c05af1d98dd3ad6367084f33fa669504491f6c74c52964295f43dd29a00394339f9032b3235ac6710cf1fda4db891bcd9ab0a73165b4bac46da2034ea1d8ae5f76e96d4811b3769d08901361dada65c8b74d1e9d1b5640b7bd5a5168a0097994203c5e57f0006d4928523c87c43513512f3e5a0be125cbb105d9a47a9e3df67f5668fc5805ae36aaa2becdb0dddb0daf1ef828885fbb6b2334315a7bf36e615040bc571eed7cb3a9647c6e6e1615f9108aedfe057b7f731660777657908caa886c833e5bb295016911f3467bbef442e58c000b37811c83ed7fd1d8575ed44e5a6e4d013c0c99a1314670944184d8439b511b7b5068b39f378faf35e0f58ad7841f5a9a201c1772693fb91cac704a231eb777e519b2d7156695b2592837d02427c9977b4dc1890b52cbffca9c2e606f3febac55a2953b4782143269761ca2d5dbbf6c7463e081982fb790d172086df02158a89b2ce67deac39ccc57b827230e455ef3ece23f5ae231bfc505a95c1b39e5a67c3c903f3f98b12c978742f92bc8eca28816b77b2b13396ceb55e78024c32e769e54e0af93d14e38ef8101ff5ac715d03e9573ed3ad8e1dafc129c068d38d24f6113fdd9aa4bde42c694c0094a4321d02c6fa5787be9d630a09e93f4f634e8e4e2c8169c7eab1286d332b6c3c6b647f3f03e2bd05404aa11dc20b8ff23eba459bef320974b6a3ee4d96fc5ac84539cdb22c1b1309c0e83eeb750224a852a037bbb61adf7b939a654e97c150a2617948a42fccf4c4b58285f2c814ce475f0784eb854ef246e9d4bc9aeebff0c845f4f9f03c6c1b404057f0856d8796883f3b92effcbcc7f3250b892ae3f251dfa6f74ef2829eeaeb2fab8148cac8cc071336bce7c44bfcfd531aeaa8800660a24e575217b02d825b33929ab1b435da7d923c42006237ac191ae595841281e733e7061e533af7bc0cdd2986da249311966f70fbfa886211cbb7e38be5f0a3e7481047040dcea6ffc879087f9fa63d2ef54a7907c51dc977ed0a9d1ff2f38e78ca87077666a6a9bbe57ecb3cc4f8136fbf9b65ec4b51c25a0f42081825e143c22567125acf37ae305d767183d83453745e18a7bcba3d716e4404cd2dc889fbf05173c8e2bfdc2dd03783a076565f2603b4a8faa5b68ad1092061e78db8e67f1606f3849b605928d2c2c9e25e072ccbd048a9d60cb7dc460da621d44e6dcaa82526236fccc04b61c179b8b27f8d8f1049360853f44d74d26086711300c9e4def92d1d9a1cb1674c19135625614474d72b39d176e7eaa2e741ded24edfb2a62c27a6d3193676212bb712d9fff7a5f624da9f60356c2309c7f1b8d4e576c48b59bb15c84c4bfe57ab168d3fed81214e10b2a66374c7ff736ac83173dd244c11418f2c63125cd33f819bf378de090ebac0004eba84ff46e4b6e9e24d143001e8cf6d9c1c55b5a72ef86f0925ded3ebb640478d6adb5becdf768949310038b3786dc077b286b166fe3bc7e54a64f357f2a514ca0ecf4151d51aba5f64d9f5001b5126605da6e95f1679f124419baad1c9bce62264580f4e9d720e59c89bf8e4d2972c1a885c7c9faa7e016018244ac93d1a185be25c9801a8fe5ee7a1f24faff40b81c915af02875ebbea763e0f944291ab57cdce959a25da9da482afe5d6da59dc16f1c96329d9ca9470a634168d31513e1bd62fca1130d2b3f1e0c31a9ee3e55b6ee0908332580b460242ae9928cb703bd291a14c8d8fe4dcd7524548be383699475937652dd7c00fe25bab30b4f91efb253dc6ca874b1bda4f1f12e6898bab6ef93565e0fdab1bf7b2512c6068e95a52a6e06eddeb63a6b7e2862822230a53837ab180bd83de3334252b0fac43544800c49efdc60de0c59da46de36501cfba5ddb50365069942ab7454c2c480bbcfed0d186be84c87a296be838f68d5336911e327f53b58650a1456f9c7c2d84de12eb7ec2f0aba28f0435183d1b3643392850b9e62cd322555e8f72fc8813542cc9f4cf32cb790a817818efbc2dd58929ca06f845795e67569f6f597d555f5b211fb2a5c4db7a73e14195a005bc2bc40297fcb75b34933a195e89cd846976f510aa3dbc56b1b0a13f0ee2a7421d2918ddf71c081198bd578c858acbbe3d8432a7e45ebb64ddbff100aceb7989fe013e63038991fe7f10cb9df61612cf1502494aed2e109b00267a1c43f946dfe32b4a6aedb7bd6b64003d8be4b36d13c0c47c62c577c11da0b84bd682ff3f4e2921d94f1ee520a8792b475133fd0a6fcfbd148770dc97661bc808e0aefe823733015bffa4ffde0d24bc251e676e691264355e529a9a48354b5c408ad5e6faa2e28b78d0493c7eda128cc5d0c2435b0e824628c1a3dcde7067c83cf793415ece14f40ff9ceb43045b67f66742081fd92235cb8fb958602d8b377ed86f5ab99cc8e0100a1b1a87e55bf598ed1576204cb168afcfe5d5d0e37ca6beeaf89531bf9fb87c16ef058c9cf837ec87219035b988cbdaf78c3640e349688ea19405bdcdb623bb59c3e6f2589c60762105f29cb08b5bb58b92695f714f7b7ba38ebe57931b1839bedc18a1f51a33f86549c9b3322270409024b9386458b8b3f2d62c2517f76a648a5695f0a8e9b58373304e6ee01712f69de98a86ac1d4fb825727b5dea54a62e355b5eb09ec0cbd0019759e18b073dbdb67e7a85376a4f5bc2faf904bc8cf774e72d0eb04d451ad7f6d3718936accc83f3f34f0a380a01eb6cfc13c61063aa6891cbc95ebcf93742b8f34439b39720830d5a01c95fdbad70747c12ea62acab735334c5483dc1cf461bd2270a9955f0c5a7bcd1446e136ea20cf749e118fa97ecc6155bbf8e4c6b391fde87dd61f50ceeed32d5cded3347001421057f539af18e98b3f1056b5f936d1bc31f27c1d97563010fb217b615b97471c79c29ac7ef91885b3664f027663c1ebaf8d85237d62c7ffc9c1e64413773cde95a4e9d341321610b6339bb69a98bfd6d2e8a731ca06b0198122f641048fcb1f76b42a8e9be67885b20dfc0f4f3599eaa89c8abd7afb7953fe98d3715d639e97f5d7485a81cc4a778a818fea7d5844fb77c2f3813555788404b8fe3ba069352a577afb2fdb7464900866a03a3a8731003bc779a31077138aac3d6301a58e9ef1a1e5a76dcefb0886514b44b1df23203ed3411faa7aa2000267611ad87ea15f852dd19c71561752583697d3129b65556190e1f9ad3494b44169c3ef9ba026f487e70df73d958ad512fdf0d27eb2df49d919f5e7d4ff2cac04fb5c1c0b7ecd083588f42469709a4d9df82080814e97b1e3157b56999bce5b79b1580d68324cface89a85bf24c86bc4466369289ab2e8f63a12ee81f36af3884b768da469f8aa0132a4d5886a69fd947c1297a1590eec9bb209c2c01f96f59c0dac030d4c8cb1bb83cb57c9e7b530b1308cbbf71c299b854741a127392854fa71bb7b1f20f9f8356d062af58d17bb7a3287831a8778110665aba005209f57d442d3309d9343ca2aec1dd170b9b94114cf204f0efea91324b923b7a503c53ab630a757a9b934349c95f37dd45ac8f954f6f9c6b208575db5f253f1ab5bb44e3932264789b4b1389c11ba9b4cdb050b26505e20d3d3b1ac3c077b97ba2f66f78befcc46eb5e02542afb442698d9cde3888a973c0bd3c912fcad51678c2a44dd7efd6e2ae70892a3cae907cf49d710b4821c057f2a0f3ce9b8a919b5b25fe627f2c6102ebb20e43e380c2215c2feefef8429bd55c153861a537316e71326f4ea6e8a7b6ee1e01a978f768431ee6b624160593fd99126bdb442d4049a9995e798c956d84dc45518fe19398e9bd0c0a4bae559e4ace1f4b5eebd2808d5cd5581fb1128794923f366a61fe6c7ea13a7450e9f1e587b74aee62ae1ab83f907104060930efcaf93c92d94202f540d06f21296206327aa7b3a4bc05297bb15b7042a7b37730707012b245ab4673c022da2a12e29ad85b71c0a7f2611d3004e5b494565dbff17454fbc418ededd3acdf76247d3c3e3a2c581ec3f2bf2898ab4d5c20bf048e4ca29a3dc1ee83c553e87ae1e6c53c54a0ad366e7d0535ebb2516879291d5d30fabbe1b59b00ac33ab291f5babced2e596c06a7a6400b8b06fd1d6e73a791e14192ef2da3c43668cf9d197909e91a30162304179aeadae651dbd654ecf4393dcf78f3f3f2198fdd9481d13144f2dd71c2fac66686b2a33aa28668077a116376d532c70f28db7fe61a1f338fc06ae64234e21376bbbd285218719f92e8ce92f075a5c9c0e475fe9153314c23ca3f39d762b4b903cb7516511a14f321b9a1d5ce10035926d13b5a0149b99d6c74bfd67c585ea51b9624442fb3b1e810fd6cb785bfd37fd5fe9c1d3e3d9e0d6dc3e0f1aea833b5609aeb4602388056687feba5c23856a43ff09a2c2f7a742da4ce24098a6744eaf14761cd510b2159ff78e1c36d3e03b7166dec89efc77ff3f2ba6bcf21b4bd611e800939503817487fdc95886bf253458817bdf35170bab51858f385deed11947e9de1143d25bcfb4f32d7b7c8f3e87e51cf4f4ac41c311c16b45ac65799f8c6140add188de04fcc309789d8ba6351b633605c56240bd3f653d92bfa44867397fdd049334b901a8ef07392f91d5e12d5e225ecd706c65f35c20c20d8b8ee88bf19fbfe642923ab8345c075e4ccd30bf47ae4bae1f4d87bfa6dcb47351ba8704fabd8c24e1f06a8dcf8becb68a5d7241cc553249f65d11588e316a5bc9bc65cc51d6c179303338b956b4b43c91d8e75f745e7a88419a65f24d45fc0b38204cdd97b61caa9b54f638f94f47f6f0c8123052f84dc2ef265ac70228d8a3aba8e02338842c2e235956246a733bfde90e379c20fb8378f14b56a12e904244a0705baf3dbb6c41462e40fc970655016ac26a1587049e7b9f623d35cf6b30ce355cbac120afb3411205c9f07802dca75aca44650278167bd4adea1b77b620b2d5aaa4ba9d5a7f9878f6dc6061efc3ffa6a57c18417eb0bec11f75827a6356e306df382d5fb119211eca9424b64baa536e96e09ec331decafb168b31a494de394d7c02e0f99faada075343c62b4c39817b794920bc590aae3e6ffc3c0c6622916d844ccf71d4ce688a6aa53591c98b746f2c4051c70a59843f8c5367fc27136f411ea252253281babda269df514ae853250c288dba44d7479c4a6fd7716fd9d83ef3405c0305ad7f9c22edb35ba528f09ee2411ac515047e1de3b1dbf92e7681383724a7c4a1f88a1e362608f5fcd676734f5ee26451cda878b0ee2ae685a4a9559a13e8365d051b0ce116ea51a516341913d2992203eecb3016509f3cbe6add241c75a30acce83440e94857b326e69c821be38733566e050953464f2a9475d0589b45885c2b8e2a1fdf1261302ec4e73f8e5a215c0c930fc1ec79074a9c35f362ebb48c96c7092c6d897c661f93fa6a03d1ffbded24ab57f72fedb6664f3def29f7acc873335379417be5a12461967e76c9de61fdc3eceb8ad17b69e79fc93d6f821ae763f669cdd2b8fb50a694e32302748852d16c42ba78faba302243db78c3839dfb9a50109db41ab6ea547ad139c5dc69b5e22e4a45511fec17d2d1d3a88bb00af4fcf57eb63838d9cfe122be08b6b06c86695b0bff34b8da0f2bfcd2ee7dfeb20b372cb39b68ff3289cbb483eef923cf77d32a505a86a62d134050061c9ab1575f95b2239449bf2ee98d84b73b1254b1525e3c0252219b21ef4ecafdaf8e4c521431ad8a1f4909d4db7d8b178b2a2c8be462387145d1f7f41f9005cf66a889054053b914e5ebd33a603f9d734137856a42de23095d6c268585dcedf9f226abcaeb031a138bd7deea5f407daaa879e0c9eebd2069b0b121d367c9c2a447d18fefa1424596a3a11f784b5f5212cbad8dfbc9c00a798c401476771408a8c2fe5","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"5adcc9623a1db749df71e4b0e1bbcc5d"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
